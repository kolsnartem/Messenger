const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const sqlite3 = require('sqlite3').verbose();
const cors = require('cors');
const fs = require('fs');
const https = require('https');
const multer = require('multer');
const path = require('path');

const app = express();
const options = {
  key: fs.readFileSync('./certs/key.pem'),
  cert: fs.readFileSync('./certs/cert.pem')
};
const server = https.createServer(options, app);
const io = socketIo(server, {
  cors: { origin: '*', methods: ['GET', 'POST'] },
  pingTimeout: 5000,
  pingInterval: 10000
});

app.use(cors());
app.use(express.json());

// –°—Ç–≤–æ—Ä—é—î–º–æ –ø–∞–ø–∫—É uploads, —è–∫—â–æ —ó—ó –Ω–µ —ñ—Å–Ω—É—î
if (!fs.existsSync('./uploads')) {
  fs.mkdirSync('./uploads');
}

// –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–æ—Å—Ç—É–ø—É –¥–æ —Å—Ç–∞—Ç–∏—á–Ω–∏—Ö —Ñ–∞–π–ª—ñ–≤
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));

// –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è multer –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—ñ–≤
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, './uploads');
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const ext = path.extname(file.originalname);
    cb(null, uniqueSuffix + ext);
  }
});

const upload = multer({ storage: storage });

// ANSI-–∫–æ–¥–∏ –¥–ª—è –∫–æ–ª—å–æ—Ä—ñ–≤
const colors = {
  green: '\x1b[32m',
  yellow: '\x1b[33m',
  cyan: '\x1b[36m',
  red: '\x1b[31m',
  blue: '\x1b[34m',
  reset: '\x1b[0m'
};

const db = new sqlite3.Database('./messenger.db', (err) => {
  if (err) console.error('SQLite connection error:', err);
  console.log('Connected to SQLite database');
});

// –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ö–µ–º—É –±–∞–∑–∏ –¥–∞–Ω–∏—Ö, —è–∫—â–æ –Ω–µ–æ–±—Ö—ñ–¥–Ω–æ
db.serialize(() => {
  db.run(`CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    email TEXT UNIQUE NOT NULL,
    password TEXT NOT NULL,
    publicKey TEXT
  )`);
  
  // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ —ñ—Å–Ω—É—é—Ç—å –Ω–æ–≤—ñ —Å—Ç–æ–≤–ø—Ü—ñ —É —Ç–∞–±–ª–∏—Ü—ñ messages
  db.all("PRAGMA table_info(messages)", (err, rows) => {
    if (err) {
      console.error('Error checking table schema:', err);
      return;
    }
    
    // –Ø–∫—â–æ —Ç–∞–±–ª–∏—Ü—è –≤–∂–µ –º—ñ—Å—Ç–∏—Ç—å –Ω–æ–≤—ñ —Å—Ç–æ–≤–ø—Ü—ñ, –ø—Ä–æ–ø—É—Å–∫–∞—î–º–æ
    if (rows && rows.some(row => row.name === 'content')) {
      console.log('Database schema is up to date');
    } else {
      // –ü–µ—Ä–µ–π–º–µ–Ω–æ–≤—É—î–º–æ —Å—Ç–∞—Ä—É —Ç–∞–±–ª–∏—Ü—é
      db.run("ALTER TABLE messages RENAME TO messages_old", (err) => {
        if (err) {
          console.error('Error renaming table:', err);
          return;
        }
        
        // –°—Ç–≤–æ—Ä—é—î–º–æ –Ω–æ–≤—É —Ç–∞–±–ª–∏—Ü—é –∑ –æ–Ω–æ–≤–ª–µ–Ω–æ—é —Å—Ö–µ–º–æ—é
        db.run(`CREATE TABLE messages (
          id TEXT PRIMARY KEY,
          userId TEXT NOT NULL,
          contactId TEXT NOT NULL,
          content TEXT NOT NULL,
          type TEXT NOT NULL,
          timestamp INTEGER NOT NULL,
          isRead INTEGER DEFAULT 0,
          isP2P INTEGER DEFAULT 0
        )`, (err) => {
          if (err) {
            console.error('Error creating new table:', err);
            return;
          }
          
          // –ü–µ—Ä–µ–Ω–æ—Å–∏–º–æ –¥–∞–Ω—ñ –∑—ñ —Å—Ç–∞—Ä–æ—ó —Ç–∞–±–ª–∏—Ü—ñ –≤ –Ω–æ–≤—É
          db.run(`INSERT INTO messages (id, userId, contactId, content, type, timestamp, isRead, isP2P)
                  SELECT id, userId, contactId, text, 'text', timestamp, isRead, isP2P
                  FROM messages_old`, (err) => {
            if (err) {
              console.error('Error migrating data:', err);
            } else {
              console.log('Database schema updated successfully');
              
              // –í–∏–¥–∞–ª—è—î–º–æ —Å—Ç–∞—Ä—É —Ç–∞–±–ª–∏—Ü—é –ø—ñ—Å–ª—è —É—Å–ø—ñ—à–Ω–æ—ó –º—ñ–≥—Ä–∞—Ü—ñ—ó
              db.run("DROP TABLE messages_old", (err) => {
                if (err) console.error('Error dropping old table:', err);
              });
            }
          });
        });
      });
    }
  });
  
      db.run(`CREATE TABLE IF NOT EXISTS deleted_messages_log (
    log_id INTEGER PRIMARY KEY AUTOINCREMENT,
    message_id TEXT NOT NULL,
    sender_id TEXT NOT NULL,
    receiver_id TEXT NOT NULL,
    message_content TEXT NOT NULL,
    message_type TEXT NOT NULL,
    deleted_at INTEGER NOT NULL
  )`);
});

const users = new Map();

io.on('connection', (socket) => {
  const userId = socket.handshake.query.userId;
  if (!userId) return socket.disconnect();
  users.set(userId, socket.id);
  console.log(`New Socket.IO connection for user: ${userId}, total users: ${users.size}`);

  // –ù–∞–¥—Å–∏–ª–∞—î–º–æ –≤—Å—ñ —Ç–∏–º—á–∞—Å–æ–≤–æ –∑–±–µ—Ä–µ–∂–µ–Ω—ñ –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—Ä–∏ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—ñ
  db.all(
    `SELECT id, userId, contactId, content, type, timestamp, isRead, isP2P 
     FROM messages 
     WHERE contactId = ? AND isRead = 0 
     ORDER BY timestamp`,
    [userId],
    (err, rows) => {
      if (err) {
        console.error('Error fetching unread messages:', err);
        return;
      }
      rows.forEach((msg) => {
        // –î–æ–¥–∞—î–º–æ text –¥–ª—è –∑–≤–æ—Ä–æ—Ç–Ω–æ—ó —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ
        const compatibleMsg = { ...msg, text: msg.content };
        socket.emit('message', compatibleMsg);
      });
      console.log(`${colors.yellow}Sent ${rows.length} unread messages to user ${userId}${colors.reset}`);
    }
  );

  socket.on('message', (msg) => {
    // –û–±—Ä–æ–±–ª—è—î–º–æ –ø–æ–ª—è –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ
    if (!msg) return;
    
    // –ë–∞–∑–æ–≤–∞ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –æ–±'—î–∫—Ç–∞ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    if (!msg.userId || !msg.contactId) {
      console.error('Invalid message format, missing userId or contactId');
      return;
    }
    
    // –í—Å—Ç–∞–Ω–æ–≤–ª—é—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º
    if (!msg.type) msg.type = 'text';
    
    // –û–±—Ä–æ–±–ª—è—î–º–æ –≤–∏–ø–∞–¥–æ–∫, –∫–æ–ª–∏ –º–æ–∂–µ –±—É—Ç–∏ text –∑–∞–º—ñ—Å—Ç—å content (–∑–≤–æ—Ä–æ—Ç–Ω–∞ —Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å)
    if (msg.content === undefined && msg.text !== undefined) {
      msg.content = msg.text;
    } else if (msg.text === undefined && msg.content !== undefined) {
      msg.text = msg.content;
    } else if (msg.content === undefined && msg.text === undefined) {
      msg.content = '';
      msg.text = '';
    }
    
    const targetSocketId = users.get(msg.contactId);
    const senderSocketId = users.get(msg.userId);

    if (msg.isP2P) {
      if (targetSocketId) io.to(targetSocketId).emit('message', msg);
      return;
    }

    // –Ø–∫—â–æ –æ—Ç—Ä–∏–º—É–≤–∞—á –æ–Ω–ª–∞–π–Ω, –ø–µ—Ä–µ–Ω–∞–ø—Ä–∞–≤–ª—è—î–º–æ –±–µ–∑ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è
    if (targetSocketId) {
      io.to(targetSocketId).emit('message', msg);
      if (senderSocketId) io.to(senderSocketId).emit('message', msg); // –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–Ω–∏–∫—É
      console.log(`${colors.green}üì© ${msg.userId} ‚Üí ${msg.contactId} (online, no save):${colors.reset} "${msg.content}" (type: ${msg.type})`);
    } else {
      // –Ø–∫—â–æ –æ—Ç—Ä–∏–º—É–≤–∞—á –æ—Ñ–ª–∞–π–Ω, –∑–±–µ—Ä—ñ–≥–∞—î–º–æ —Ç–∏–º—á–∞—Å–æ–≤–æ
      db.run(
        'INSERT INTO messages (id, userId, contactId, content, type, timestamp, isRead, isP2P) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
        [msg.id, msg.userId, msg.contactId, msg.content, msg.type, msg.timestamp, 0, msg.isP2P || 0],
        (err) => {
          if (err) {
            console.error('Failed to save message to DB:', err);
            return;
          }
          console.log(`${colors.green}üì© ${msg.userId} ‚Üí ${msg.contactId} (offline, saved):${colors.reset} "${msg.content}" (type: ${msg.type})`);
        }
      );
    }
  });

  socket.on('p2p-offer', (data) => {
    const targetSocketId = users.get(data.target);
    const content = JSON.stringify({ type: 'offer', sdp: data.offer.sdp });
    
    if (targetSocketId) {
      io.to(targetSocketId).emit('p2p-offer', { offer: data.offer, source: data.source });
      
      // –î–æ–¥–∞—î–º–æ –ø–æ–ª–µ text –¥–ª—è –∑–≤–æ—Ä–æ—Ç–Ω–æ—ó —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ
      const p2pNotifyMsg = {
        id: `p2p-request-${Date.now()}`,
        userId: data.source,
        contactId: data.target,
        content: content,
        text: content,
        type: 'text',
        timestamp: Date.now(),
        isRead: 0,
        isP2P: true,
      };
      io.to(targetSocketId).emit('p2p-offer-notify', {
        message: p2pNotifyMsg
      });
    } else {
      const messageId = `p2p-offer-${Date.now()}`;
      const timestamp = Date.now();
      
      db.run(
        'INSERT INTO messages (id, userId, contactId, content, type, timestamp, isRead, isP2P) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
        [messageId, data.source, data.target, content, 'text', timestamp, 0, 1],
        (err) => {
          if (err) console.error('Failed to save P2P offer:', err);
        }
      );
    }
  });

  socket.on('p2p-answer', (data) => {
    const targetSocketId = users.get(data.target);
    if (targetSocketId) io.to(targetSocketId).emit('p2p-answer', { answer: data.answer, source: data.source });
  });

  socket.on('p2p-ice-candidate', (data) => {
    const targetSocketId = users.get(data.target);
    if (targetSocketId) io.to(targetSocketId).emit('p2p-ice-candidate', { candidate: data.candidate, source: data.source });
  });

  socket.on('p2p-offer-notify', (data) => {
    // –î–æ–¥–∞—î–º–æ –ø–µ—Ä–µ–≤—ñ—Ä–∫—É –Ω–∞—è–≤–Ω–æ—Å—Ç—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
    if (!data || !data.message) {
      console.error('Invalid p2p-offer-notify data format');
      return;
    }
    
    // –ó–∞–±–µ–∑–ø–µ—á—É—î–º–æ —Å—É–º—ñ—Å–Ω—ñ—Å—Ç—å –ø–æ–ª—ñ–≤
    if (data.message.content && !data.message.text) {
      data.message.text = data.message.content;
    } else if (data.message.text && !data.message.content) {
      data.message.content = data.message.text;
    }
    
    const targetSocketId = users.get(data.message.contactId);
    if (targetSocketId) io.to(targetSocketId).emit('p2p-offer-notify', { message: data.message });
  });

  socket.on('p2p-reject', (data) => {
    const targetSocketId = users.get(data.target);
    if (targetSocketId) io.to(targetSocketId).emit('p2p-reject', { source: data.source });
  });

  socket.on('call-offer', (data) => {
    const targetSocketId = users.get(data.target);
    if (targetSocketId) io.to(targetSocketId).emit('call-offer', { offer: data.offer, source: data.source });
  });

  socket.on('call-answer', (data) => {
    const targetSocketId = users.get(data.target);
    if (targetSocketId) io.to(targetSocketId).emit('call-answer', { answer: data.answer });
  });

  socket.on('ice-candidate', (data) => {
    const targetSocketId = users.get(data.target);
    if (targetSocketId) io.to(targetSocketId).emit('ice-candidate', { candidate: data.candidate });
  });

  socket.on('call-ended', (data) => {
    const targetSocketId = users.get(data.target);
    if (targetSocketId) io.to(targetSocketId).emit('call-ended');
  });

  socket.on('disconnect', () => {
    users.delete(userId);
    console.log(`User disconnected: ${userId}, remaining users: ${users.size}`);
  });
});

app.post('/register', (req, res) => {
  const { email, password } = req.body;
  db.get('SELECT email FROM users WHERE email = ?', [email], (err, row) => {
    if (err) return res.status(500).json({ error: 'Database error' });
    if (row) return res.status(400).json({ error: 'User already exists' });
    db.run('INSERT INTO users (email, password) VALUES (?, ?)', [email, password], function(err) {
      if (err) return res.status(500).json({ error: 'Registration failed' });
      res.json({ id: this.lastID.toString() });
    });
  });
});

app.post('/login', (req, res) => {
  const { email, password } = req.body;
  db.get('SELECT id FROM users WHERE email = ? AND password = ?', [email, password], (err, row) => {
    if (err) return res.status(500).json({ error: 'Database error' });
    if (!row) return res.status(401).json({ error: 'Invalid credentials' });
    res.json({ id: row.id.toString() });
  });
});

app.put('/update-keys', (req, res) => {
  const { userId, publicKey } = req.body;
  if (!publicKey || publicKey.length !== 44) return res.status(400).json({ error: 'Invalid public key format' });
  db.run('UPDATE users SET publicKey = ? WHERE id = ?', [publicKey, userId], (err) => {
    if (err) return res.status(500).json({ error: 'Update failed' });
    console.log(`${colors.cyan}üîë ${userId}:${colors.reset} "${publicKey}"`);
    io.emit('key-updated', { userId, publicKey });
    res.json({ success: true });
  });
});

app.get('/users', (req, res) => {
  const { id } = req.query;
  if (!id) return res.status(400).json({ error: 'Missing userId' });
  db.get('SELECT id, email, publicKey FROM users WHERE id = ?', [id], (err, row) => {
    if (err) return res.status(500).json({ error: 'Database error' });
    if (!row) return res.status(404).json({ error: 'User not found' });
    res.json({ id: row.id.toString(), email: row.email, publicKey: row.publicKey || '' });
  });
});

app.get('/search', (req, res) => {
  const { query } = req.query;
  db.all('SELECT id, email, publicKey FROM users WHERE email LIKE ?', [`%${query}%`], (err, rows) => {
    if (err) return res.status(500).json({ error: 'Search failed' });
    res.json(rows.map(row => ({ id: row.id.toString(), email: row.email, publicKey: row.publicKey || '' })));
  });
});

app.get('/chats', (req, res) => {
  const { userId } = req.query;
  if (!userId) return res.status(400).json({ error: 'Missing userId' });
  db.all(
    `SELECT DISTINCT u.id, u.email, u.publicKey 
     FROM users u
     INNER JOIN messages m 
     ON (u.id = m.userId OR u.id = m.contactId)
     WHERE (m.userId = ? OR m.contactId = ?) AND u.id != ?`,
    [userId, userId, userId],
    (err, rows) => {
      if (err) return res.status(500).json({ error: 'Database error' });
      const contacts = rows.map(row => ({ id: row.id.toString(), email: row.email, publicKey: row.publicKey || '' }));
      Promise.all(
        contacts.map(contact =>
          new Promise((resolve) => {
            db.get(
              `SELECT id, userId, contactId, content, type, timestamp, isRead 
               FROM messages 
               WHERE (userId = ? AND contactId = ?) OR (userId = ? AND contactId = ?) 
               ORDER BY timestamp DESC LIMIT 1`,
              [userId, contact.id, contact.id, userId],
              (err, msg) => {
                if (err) resolve({ ...contact, lastMessage: null });
                else {
                  // –î–æ–¥–∞—î–º–æ –ø–æ–ª–µ text –¥–ª—è –∑–≤–æ—Ä–æ—Ç–Ω–æ—ó —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ
                  const lastMsg = msg ? { ...msg, text: msg.content } : null;
                  resolve({ ...contact, lastMessage: lastMsg });
                }
              }
            );
          })
        )
      ).then(results => {
        res.json(results.sort((a, b) => (b.lastMessage?.timestamp || 0) - (a.lastMessage?.timestamp || 0)));
      });
    }
  );
});

app.get('/messages', (req, res) => {
  const { userId, contactId } = req.query;
  db.all(
    `SELECT id, userId, contactId, content, type, timestamp, isRead, isP2P 
     FROM messages 
     WHERE (userId = ? AND contactId = ?) OR (userId = ? AND contactId = ?) 
     ORDER BY timestamp`,
    [userId, contactId, contactId, userId],
    (err, rows) => {
      if (err) return res.status(500).json({ error: 'Database error' });
      // –î–æ–¥–∞—î–º–æ –ø–æ–ª–µ text –¥–ª—è –∑–≤–æ—Ä–æ—Ç–Ω–æ—ó —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ
      const compatibleRows = rows.map(row => ({...row, text: row.content}));
      res.json(compatibleRows);
    }
  );
});

app.post('/mark-as-read', (req, res) => {
  const { userId, contactId } = req.body;
  db.all(
    `SELECT id, userId, contactId, content, type FROM messages WHERE contactId = ? AND userId = ? AND isRead = 0`,
    [userId, contactId],
    (err, rows) => {
      if (err) return res.status(500).json({ error: 'Database error' });
      const messagesToDelete = rows;
      if (messagesToDelete.length === 0) return res.json({ success: true });

      // –í–∏–¥–∞–ª—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –ø—ñ—Å–ª—è –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—è
      db.run(
        `DELETE FROM messages WHERE contactId = ? AND userId = ? AND isRead = 0`,
        [userId, contactId],
        (deleteErr) => {
          if (deleteErr) return res.status(500).json({ error: 'Database error' });
          messagesToDelete.forEach(msg => {
            const senderSocketId = users.get(contactId);
            if (senderSocketId) {
              io.to(senderSocketId).emit('message-read', { messageId: msg.id, contactId: userId });
            }
            console.log(`${colors.cyan}üóëÔ∏è Deleted after read: ${msg.userId} ‚Üí ${msg.contactId}:${colors.reset} "${msg.content}" (type: ${msg.type})`);
          });
          res.json({ success: true });
        }
      );
    }
  );
});

// –†–æ—É—Ç –¥–ª—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ñ–∞–π–ª—ñ–≤
app.post('/upload', upload.single('file'), (req, res) => {
  if (!req.file) {
    return res.status(400).json({ error: 'No file provided' });
  }

  const { userId, contactId } = req.body;
  if (!userId || !contactId) {
    return res.status(400).json({ error: 'Missing userId or contactId' });
  }

  const filePath = `/uploads/${req.file.filename}`;
  const fileType = req.file.mimetype.startsWith('image/') ? 'image' : 'file';
  const messageId = `${Date.now()}-${Math.round(Math.random() * 1E9)}`;
  const timestamp = Date.now();

  // –§–æ—Ä–º—É—î–º–æ –æ–±'—î–∫—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
  const message = {
    id: messageId,
    userId,
    contactId,
    content: filePath,
    text: filePath, // –î–æ–¥–∞—î–º–æ –ø–æ–ª–µ text –¥–ª—è –∑–≤–æ—Ä–æ—Ç–Ω–æ—ó —Å—É–º—ñ—Å–Ω–æ—Å—Ç—ñ
    type: fileType,
    timestamp,
    isRead: 0,
    isP2P: 0
  };

  // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –æ—Ç—Ä–∏–º—É–≤–∞—á –æ–Ω–ª–∞–π–Ω
  const targetSocketId = users.get(contactId);
  const senderSocketId = users.get(userId);

  if (targetSocketId) {
    // –Ø–∫—â–æ –æ—Ç—Ä–∏–º—É–≤–∞—á –æ–Ω–ª–∞–π–Ω, –Ω–∞–¥—Å–∏–ª–∞—î–º–æ –π–æ–º—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –±–µ–∑ –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –≤ –ë–î
    io.to(targetSocketId).emit('message', message);
    if (senderSocketId) io.to(senderSocketId).emit('message', message); // –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–Ω–∏–∫—É
    console.log(`${colors.blue}üì§ ${userId} ‚Üí ${contactId} (online, file sent):${colors.reset} "${filePath}" (type: ${fileType})`);
    res.json({ success: true, message });
  } else {
    // –Ø–∫—â–æ –æ—Ç—Ä–∏–º—É–≤–∞—á –æ—Ñ–ª–∞–π–Ω, –∑–±–µ—Ä—ñ–≥–∞—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –≤ –ë–î
    db.run(
      'INSERT INTO messages (id, userId, contactId, content, type, timestamp, isRead, isP2P) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
      [messageId, userId, contactId, filePath, fileType, timestamp, 0, 0],
      (err) => {
        if (err) {
          console.error('Failed to save file message to DB:', err);
          return res.status(500).json({ error: 'Failed to save message' });
        }
        console.log(`${colors.blue}üì§ ${userId} ‚Üí ${contactId} (offline, file saved):${colors.reset} "${filePath}" (type: ${fileType})`);
        if (senderSocketId) io.to(senderSocketId).emit('message', message); // –ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –≤—ñ–¥–ø—Ä–∞–≤–Ω–∏–∫—É
        res.json({ success: true, message });
      }
    );
  }
});

process.on('SIGINT', () => {
  db.close((err) => {
    if (err) console.error('Error closing database:', err);
    console.log('Database connection closed');
    process.exit(0);
  });
});

const PORT = 4000;
server.listen(PORT, '100.64.221.88', () => {
  console.log(`Server running on https://100.64.221.88:${PORT}`);
});