"use strict";
//
// Copyright 2023 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.Net = exports.SIGNAL_TLS_PROXY_SCHEME = exports.buildHttpRequest = exports.AuthenticatedChatConnection = exports.UnauthenticatedChatConnection = exports.ChatServerMessageAck = exports.TokioAsyncContext = exports.newNativeHandle = exports.Environment = void 0;
const Native = require("../Native");
const Address_1 = require("./Address");
const node_buffer_1 = require("node:buffer");
const DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS = 5000;
// This must match the libsignal-bridge Rust enum of the same name.
var Environment;
(function (Environment) {
    Environment[Environment["Staging"] = 0] = "Staging";
    Environment[Environment["Production"] = 1] = "Production";
})(Environment || (exports.Environment = Environment = {}));
function newNativeHandle(handle) {
    return {
        _nativeHandle: handle,
    };
}
exports.newNativeHandle = newNativeHandle;
/** Low-level async runtime control, mostly just exported for testing. */
class TokioAsyncContext {
    constructor(handle) {
        this._nativeHandle = handle;
    }
    makeCancellable(abortSignal, promise) {
        if (abortSignal !== undefined) {
            const cancellationToken = promise._cancellationToken;
            const cancel = () => {
                Native.TokioAsyncContext_cancel(this, cancellationToken);
            };
            if (abortSignal.aborted) {
                cancel();
            }
            else {
                abortSignal.addEventListener('abort', cancel);
            }
        }
        return promise;
    }
}
exports.TokioAsyncContext = TokioAsyncContext;
class ChatServerMessageAck {
    constructor(_nativeHandle) {
        this._nativeHandle = _nativeHandle;
    }
    send(statusCode) {
        Native.ServerMessageAck_SendStatus(this, statusCode);
    }
}
exports.ChatServerMessageAck = ChatServerMessageAck;
class ConnectionInfoImpl {
    constructor(_nativeHandle) {
        this._nativeHandle = _nativeHandle;
    }
    get localPort() {
        return Native.ChatConnectionInfo_local_port(this);
    }
    get ipVersion() {
        const value = Native.ChatConnectionInfo_ip_version(this);
        switch (value) {
            case 1:
                return 'IPv4';
            case 2:
                return 'IPv6';
            default:
                throw new TypeError(`ip type was unexpectedly ${value}`);
        }
    }
    toString() {
        return Native.ChatConnectionInfo_description(this);
    }
}
class UnauthenticatedChatConnection {
    static async connect(asyncContext, connectionManager, listener, options) {
        const nativeChatListener = makeNativeChatListener(asyncContext, listener);
        const connect = Native.UnauthenticatedChatConnection_connect(asyncContext, connectionManager);
        const chat = await asyncContext.makeCancellable(options?.abortSignal, connect);
        const connection = newNativeHandle(chat);
        Native.UnauthenticatedChatConnection_init_listener(connection, new WeakListenerWrapper(nativeChatListener));
        return new UnauthenticatedChatConnection(asyncContext, connection, nativeChatListener);
    }
    constructor(asyncContext, chatService, 
    // Unused except to keep the listener alive since the Rust code only holds a
    // weak reference to the same object.
    chatListener) {
        this.asyncContext = asyncContext;
        this.chatService = chatService;
        this.chatListener = chatListener;
    }
    fetch(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.UnauthenticatedChatConnection_send(this.asyncContext, this.chatService, buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
    disconnect() {
        return Native.UnauthenticatedChatConnection_disconnect(this.asyncContext, this.chatService);
    }
    connectionInfo() {
        return new ConnectionInfoImpl(Native.UnauthenticatedChatConnection_info(this.chatService));
    }
}
exports.UnauthenticatedChatConnection = UnauthenticatedChatConnection;
class AuthenticatedChatConnection {
    static async connect(asyncContext, connectionManager, username, password, receiveStories, listener, options) {
        const nativeChatListener = makeNativeChatListener(asyncContext, listener);
        const connect = Native.AuthenticatedChatConnection_connect(asyncContext, connectionManager, username, password, receiveStories);
        const chat = await asyncContext.makeCancellable(options?.abortSignal, connect);
        const connection = newNativeHandle(chat);
        Native.AuthenticatedChatConnection_init_listener(connection, new WeakListenerWrapper(nativeChatListener));
        return new AuthenticatedChatConnection(asyncContext, connection, nativeChatListener);
    }
    /**
     * Creates a chat connection backed by a fake remote end.
     *
     * @param asyncContext the async runtime to use
     * @param listener the listener to send events to
     * @returns an {@link AuthenticatedChatConnection} and handle for the remote
     * end of the fake connection.
     */
    static fakeConnect(asyncContext, listener) {
        const nativeChatListener = makeNativeChatListener(asyncContext, listener);
        const fakeChat = newNativeHandle(Native.TESTING_FakeChatConnection_Create(asyncContext, new WeakListenerWrapper(nativeChatListener)));
        const chat = newNativeHandle(Native.TESTING_FakeChatConnection_TakeAuthenticatedChat(fakeChat));
        return [
            new AuthenticatedChatConnection(asyncContext, chat, nativeChatListener),
            newNativeHandle(Native.TESTING_FakeChatConnection_TakeRemote(fakeChat)),
        ];
    }
    constructor(asyncContext, chatService, 
    // Unused except to keep the listener alive since the Rust code only holds a
    // weak reference to the same object.
    chatListener) {
        this.asyncContext = asyncContext;
        this.chatService = chatService;
        this.chatListener = chatListener;
    }
    fetch(chatRequest, options) {
        return this.asyncContext.makeCancellable(options?.abortSignal, Native.AuthenticatedChatConnection_send(this.asyncContext, this.chatService, buildHttpRequest(chatRequest), chatRequest.timeoutMillis ?? DEFAULT_CHAT_REQUEST_TIMEOUT_MILLIS));
    }
    disconnect() {
        return Native.AuthenticatedChatConnection_disconnect(this.asyncContext, this.chatService);
    }
    connectionInfo() {
        return new ConnectionInfoImpl(Native.AuthenticatedChatConnection_info(this.chatService));
    }
}
exports.AuthenticatedChatConnection = AuthenticatedChatConnection;
/**
 * Holds a {@link Native.ChatListener} by {@link WeakRef} and delegates
 * `ChatListener` calls to it.
 *
 * This lets us avoid passing anything across the bridge that has a normal
 * (strong) reference to the app-side listener. The danger is that the passed-in
 * listener might gain a reference to the JS connection object; that would
 * result in a reference cycle that Node can't clean up because one of the
 * references is through a Rust `Box`.
 *
 * When constructing a connection, calling code should wrap an app-side listener
 * in this type and pass it across the bridge, then hold its own strong
 * reference to the same listener as a field. This ensures that if there is a
 * reference cycle between the connection and app-side listener, that cycle is
 * visible to the Node runtime, while still ensuring the passed-in listener
 * stays alive as long as the connection does.
 */
class WeakListenerWrapper {
    constructor(listener) {
        this.listener = new WeakRef(listener);
    }
    _connection_interrupted(reason) {
        this.listener.deref()?._connection_interrupted(reason);
    }
    _incoming_message(envelope, timestamp, ack) {
        this.listener.deref()?._incoming_message(envelope, timestamp, ack);
    }
    _queue_empty() {
        this.listener.deref()?._queue_empty();
    }
}
function makeNativeChatListener(asyncContext, listener) {
    if ('onQueueEmpty' in listener) {
        return {
            _incoming_message(envelope, timestamp, ack) {
                listener.onIncomingMessage(envelope, timestamp, new ChatServerMessageAck(ack));
            },
            _queue_empty() {
                listener.onQueueEmpty();
            },
            _connection_interrupted(cause) {
                listener.onConnectionInterrupted(cause);
            },
        };
    }
    return {
        _incoming_message(_envelope, _timestamp, _ack) {
            throw new Error('Event not supported on unauthenticated connection');
        },
        _queue_empty() {
            throw new Error('Event not supported on unauthenticated connection');
        },
        _connection_interrupted(cause) {
            listener.onConnectionInterrupted(cause);
        },
    };
}
function buildHttpRequest(chatRequest) {
    const { verb, path, body, headers } = chatRequest;
    const bodyBuffer = body !== undefined ? node_buffer_1.Buffer.from(body) : null;
    const httpRequest = {
        _nativeHandle: Native.HttpRequest_new(verb, path, bodyBuffer),
    };
    headers.forEach((header) => {
        const [name, value] = header;
        Native.HttpRequest_add_header(httpRequest, name, value);
    });
    return httpRequest;
}
exports.buildHttpRequest = buildHttpRequest;
/** The "scheme" for Signal TLS proxies. See {@link Net.setProxy()}. */
exports.SIGNAL_TLS_PROXY_SCHEME = 'org.signal.tls';
class Net {
    constructor(options) {
        this.asyncContext = new TokioAsyncContext(Native.TokioAsyncContext_new());
        if (options.localTestServer) {
            this._connectionManager = newNativeHandle(Native.TESTING_ConnectionManager_newLocalOverride(options.userAgent, options.TESTING_localServer_chatPort, options.TESTING_localServer_cdsiPort, options.TESTING_localServer_svr2Port, options.TESTING_localServer_svr3SgxPort, options.TESTING_localServer_svr3NitroPort, options.TESTING_localServer_svr3Tpm2SnpPort, options.TESTING_localServer_rootCertificateDer));
        }
        else {
            this._connectionManager = newNativeHandle(Native.ConnectionManager_new(options.env, options.userAgent));
        }
    }
    /**
     *
     * Creates a new instance of {@link UnauthenticatedChatConnection}.
     * @param listener the listener for incoming events.
     * @param options additional options to pass through.
     * @param options.abortSignal an {@link AbortSignal} that will cancel the connection attempt.
     * @returns the connected listener, if the connection succeeds.
     */
    async connectUnauthenticatedChat(listener, options) {
        return UnauthenticatedChatConnection.connect(this.asyncContext, this._connectionManager, listener, options);
    }
    /**
     * Creates a new instance of {@link AuthenticatedChatConnection}.
     */
    connectAuthenticatedChat(username, password, receiveStories, listener, options) {
        return AuthenticatedChatConnection.connect(this.asyncContext, this._connectionManager, username, password, receiveStories, listener, options);
    }
    /**
     * Enables/disables IPv6 for all new connections (until changed).
     *
     * The flag is `true` by default.
     */
    setIpv6Enabled(ipv6Enabled) {
        Native.ConnectionManager_set_ipv6_enabled(this._connectionManager, ipv6Enabled);
    }
    /**
     * Enables or disables censorship circumvention for all new connections (until changed).
     *
     * If CC is enabled, *new* connections and services may try additional routes to the Signal
     * servers. Existing connections and services will continue with the setting they were created
     * with. (In particular, changing this setting will not affect any existing
     * {@link ChatConnection ChatConnections}.)
     *
     * CC is off by default.
     */
    setCensorshipCircumventionEnabled(enabled) {
        Native.ConnectionManager_set_censorship_circumvention_enabled(this._connectionManager, enabled);
    }
    setProxy(hostOrOptions, portOrNothing) {
        if (typeof hostOrOptions === 'string') {
            // Support <username>@<host> syntax to allow UNENCRYPTED_FOR_TESTING as a marker user.
            // This is not a stable feature of the API and may go away in the future;
            // the Rust layer will reject any other users anyway. But it's convenient for us.
            const [before, after] = hostOrOptions.split('@', 2);
            const [username, domain] = after ? [before, after] : [undefined, before];
            hostOrOptions = {
                scheme: exports.SIGNAL_TLS_PROXY_SCHEME,
                host: domain,
                port: portOrNothing,
                username,
            };
        }
        const { scheme, host, port, username, password } = hostOrOptions;
        try {
            const proxyConfig = newNativeHandle(Native.ConnectionProxyConfig_new(scheme, host, 
            // i32::MIN represents "no port provided"; we don't expect anyone to pass that manually.
            port ?? -2147483648, username ?? null, password ?? null));
            Native.ConnectionManager_set_proxy(this._connectionManager, proxyConfig);
        }
        catch (e) {
            this.setInvalidProxy();
            throw e;
        }
    }
    /**
     * Like {@link #setProxy}, but parses the proxy options from a URL. See there for more
     * information.
     *
     * Takes a string rather than a URL so that an *invalid* string can result in disabling
     * connections until {@link #clearProxy} is called, consistent with other ways {@link #setProxy}
     * might consider its parameters invalid.
     *
     * Throws if the URL contains unnecessary parts (like a query string), or if the resulting options
     * are not supported.
     */
    setProxyFromUrl(urlString) {
        let options;
        try {
            options = Net.proxyOptionsFromUrl(urlString);
        }
        catch (e) {
            // Make sure we set an invalid proxy on error,
            // so no connection can be made until the problem is fixed.
            this.setInvalidProxy();
            throw e;
        }
        this.setProxy(options);
    }
    /**
     * Parses a proxy URL into an options object, suitable for passing to {@link #setProxy}.
     *
     * It is recommended not to call this directly. Instead, use {@link #setProxyFromUrl}, which will
     * treat an invalid URL uniformly with one that is structurally valid but unsupported by
     * libsignal.
     *
     * Throws if the URL is known to not be a valid proxy URL; however it's still possible the
     * resulting options object cannot be used as a proxy.
     */
    static proxyOptionsFromUrl(urlString) {
        const url = new URL(urlString);
        // Check all the parts of the URL.
        // scheme://username:password@hostname:port/path?query#fragment
        const scheme = url.protocol.slice(0, -1);
        // This does not distinguish between "https://proxy.example" and "https://@proxy.example".
        // This could be done by manually checking `url.href`.
        // But until someone complains about it, let's not worry about it.
        const username = url.username != '' ? url.username : undefined;
        const password = url.password != '' ? url.password : undefined;
        const host = url.hostname;
        const port = url.port != '' ? Number.parseInt(url.port, 10) : undefined;
        if (url.pathname != '' && url.pathname != '/') {
            throw new Error('proxy URLs should not have path components');
        }
        if (url.search != '') {
            throw new Error('proxy URLs should not have query components');
        }
        if (url.hash != '') {
            throw new Error('proxy URLs should not have fragment components');
        }
        return { scheme, username, password, host, port };
    }
    /**
     * Refuses to make any new connections until a new proxy configuration is set or
     * {@link #clearProxy} is called.
     *
     * Existing connections will not be affected.
     */
    setInvalidProxy() {
        Native.ConnectionManager_set_invalid_proxy(this._connectionManager);
    }
    /**
     * Ensures that future connections will be made directly, not through a proxy.
     *
     * Clears any proxy configuration set via {@link #setProxy} or {@link #setInvalidProxy}. If none
     * was set, calling this method is a no-op.
     */
    clearProxy() {
        Native.ConnectionManager_clear_proxy(this._connectionManager);
    }
    /**
     * Notifies libsignal that the network has changed.
     *
     * This will lead to, e.g. caches being cleared and cooldowns being reset.
     */
    onNetworkChange() {
        Native.ConnectionManager_on_network_change(this._connectionManager);
    }
    async cdsiLookup({ username, password }, { e164s, acisAndAccessKeys, abortSignal, useNewConnectLogic, }) {
        const request = newNativeHandle(Native.LookupRequest_new());
        e164s.forEach((e164) => {
            Native.LookupRequest_addE164(request, e164);
        });
        acisAndAccessKeys.forEach(({ aci: aciStr, accessKey: accessKeyStr }) => {
            Native.LookupRequest_addAciAndAccessKey(request, Address_1.Aci.parseFromServiceIdString(aciStr).getServiceIdFixedWidthBinary(), node_buffer_1.Buffer.from(accessKeyStr, 'base64'));
        });
        const startLookup = useNewConnectLogic
            ? Native.CdsiLookup_new_routes
            : Native.CdsiLookup_new;
        const lookup = await this.asyncContext.makeCancellable(abortSignal, startLookup(this.asyncContext, this._connectionManager, username, password, request));
        return await this.asyncContext.makeCancellable(abortSignal, Native.CdsiLookup_complete(this.asyncContext, newNativeHandle(lookup)));
    }
}
exports.Net = Net;
//# sourceMappingURL=net.js.map