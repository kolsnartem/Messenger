/// <reference types="node" />
import type { ReadonlyDeep } from 'type-fest';
import * as Native from '../Native';
import { LibSignalError } from './Errors';
import { Wrapper } from '../Native';
import { Buffer } from 'node:buffer';
export declare enum Environment {
    Staging = 0,
    Production = 1
}
export type ServiceAuth = {
    username: string;
    password: string;
};
export type CDSRequestOptionsType = {
    e164s: Array<string>;
    acisAndAccessKeys: Array<{
        aci: string;
        accessKey: string;
    }>;
    /**
     * @deprecated this option is ignored by the server.
     */
    returnAcisWithoutUaks: boolean;
    abortSignal?: AbortSignal;
    useNewConnectLogic?: boolean;
};
export type CDSResponseEntryType<Aci, Pni> = {
    aci: Aci | undefined;
    pni: Pni | undefined;
};
export type CDSResponseEntries<Aci, Pni> = Map<string, CDSResponseEntryType<Aci, Pni>>;
export interface CDSResponseType<Aci, Pni> {
    entries: CDSResponseEntries<Aci, Pni>;
    debugPermitsUsed: number;
}
export type ChatRequest = Readonly<{
    verb: string;
    path: string;
    headers: ReadonlyArray<[string, string]>;
    body?: Uint8Array;
    timeoutMillis?: number;
}>;
type ConnectionManager = Wrapper<Native.ConnectionManager>;
export declare function newNativeHandle<T>(handle: T): Wrapper<T>;
/** Low-level async runtime control, mostly just exported for testing. */
export declare class TokioAsyncContext {
    readonly _nativeHandle: Native.TokioAsyncContext;
    constructor(handle: Native.TokioAsyncContext);
    makeCancellable<T>(abortSignal: AbortSignal | undefined, promise: Native.CancellablePromise<T>): Promise<T>;
}
export declare class ChatServerMessageAck {
    readonly _nativeHandle: Native.ServerMessageAck;
    constructor(_nativeHandle: Native.ServerMessageAck);
    send(statusCode: number): void;
}
export interface ConnectionEventsListener {
    /**
     * Called when the client gets disconnected from the server.
     *
     * This includes both deliberate disconnects as well as unexpected socket
     * closures. If the closure was not due to a deliberate disconnect, the error
     * will be provided.
     */
    onConnectionInterrupted(cause: LibSignalError | null): void;
}
export interface ChatServiceListener extends ConnectionEventsListener {
    /**
     * Called when the server delivers an incoming message to the client.
     *
     * `timestamp` is in milliseconds.
     *
     * If `ack`'s `send` method is not called, the server will leave this message in the message
     * queue and attempt to deliver it again in the future.
     */
    onIncomingMessage(envelope: Buffer, timestamp: number, ack: ChatServerMessageAck): void;
    /**
     * Called when the server indicates that there are no further messages in the message queue.
     *
     * Note that further messages may still be delivered; this merely indicates that all messages that
     * were in the queue *when the connection was established* have been delivered.
     */
    onQueueEmpty(): void;
}
/**
 * A connection to the Chat Service.
 *
 * Provides API methods to communicate with the remote service. Make sure to
 * call {@link #disconnect()} when the instance is no longer needed.
 */
export type ChatConnection = {
    /**
     * Initiates termination of the underlying connection to the Chat Service. After the service is
     * disconnected, it cannot be used again.
     */
    disconnect(): Promise<void>;
    /**
     * Sends request to the Chat service.
     */
    fetch(chatRequest: ChatRequest, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ChatResponse>;
    /**
     * Information about the connection to the Chat service.
     */
    connectionInfo(): ConnectionInfo;
};
export interface ConnectionInfo {
    localPort: number;
    ipVersion: 'IPv4' | 'IPv6';
    toString: () => string;
}
export declare class UnauthenticatedChatConnection implements ChatConnection {
    private readonly asyncContext;
    private readonly chatService;
    private readonly chatListener;
    static connect(asyncContext: TokioAsyncContext, connectionManager: ConnectionManager, listener: ConnectionEventsListener, options?: {
        abortSignal?: AbortSignal;
    }): Promise<UnauthenticatedChatConnection>;
    private constructor();
    fetch(chatRequest: ChatRequest, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ChatResponse>;
    disconnect(): Promise<void>;
    connectionInfo(): ConnectionInfo;
}
export declare class AuthenticatedChatConnection implements ChatConnection {
    private readonly asyncContext;
    private readonly chatService;
    private readonly chatListener;
    static connect(asyncContext: TokioAsyncContext, connectionManager: ConnectionManager, username: string, password: string, receiveStories: boolean, listener: ChatServiceListener, options?: {
        abortSignal?: AbortSignal;
    }): Promise<AuthenticatedChatConnection>;
    /**
     * Creates a chat connection backed by a fake remote end.
     *
     * @param asyncContext the async runtime to use
     * @param listener the listener to send events to
     * @returns an {@link AuthenticatedChatConnection} and handle for the remote
     * end of the fake connection.
     */
    static fakeConnect(asyncContext: TokioAsyncContext, listener: ChatServiceListener): [AuthenticatedChatConnection, Wrapper<Native.FakeChatRemoteEnd>];
    private constructor();
    fetch(chatRequest: ChatRequest, options?: {
        abortSignal?: AbortSignal;
    }): Promise<Native.ChatResponse>;
    disconnect(): Promise<void>;
    connectionInfo(): ConnectionInfo;
}
export declare function buildHttpRequest(chatRequest: ChatRequest): Wrapper<Native.HttpRequest>;
export type NetConstructorOptions = Readonly<{
    localTestServer?: false;
    env: Environment;
    userAgent: string;
} | {
    localTestServer: true;
    userAgent: string;
    TESTING_localServer_chatPort: number;
    TESTING_localServer_cdsiPort: number;
    TESTING_localServer_svr2Port: number;
    TESTING_localServer_svr3SgxPort: number;
    TESTING_localServer_svr3NitroPort: number;
    TESTING_localServer_svr3Tpm2SnpPort: number;
    TESTING_localServer_rootCertificateDer: Buffer;
}>;
/** See {@link Net.setProxy()}. */
export type ProxyOptions = {
    scheme: string;
    host: string;
    port?: number;
    username?: string;
    password?: string;
};
/** The "scheme" for Signal TLS proxies. See {@link Net.setProxy()}. */
export declare const SIGNAL_TLS_PROXY_SCHEME = "org.signal.tls";
export declare class Net {
    private readonly asyncContext;
    /** Exposed only for testing. */
    readonly _connectionManager: ConnectionManager;
    constructor(options: NetConstructorOptions);
    /**
     *
     * Creates a new instance of {@link UnauthenticatedChatConnection}.
     * @param listener the listener for incoming events.
     * @param options additional options to pass through.
     * @param options.abortSignal an {@link AbortSignal} that will cancel the connection attempt.
     * @returns the connected listener, if the connection succeeds.
     */
    connectUnauthenticatedChat(listener: ConnectionEventsListener, options?: {
        abortSignal?: AbortSignal;
    }): Promise<UnauthenticatedChatConnection>;
    /**
     * Creates a new instance of {@link AuthenticatedChatConnection}.
     */
    connectAuthenticatedChat(username: string, password: string, receiveStories: boolean, listener: ChatServiceListener, options?: {
        abortSignal?: AbortSignal;
    }): Promise<AuthenticatedChatConnection>;
    /**
     * Enables/disables IPv6 for all new connections (until changed).
     *
     * The flag is `true` by default.
     */
    setIpv6Enabled(ipv6Enabled: boolean): void;
    /**
     * Enables or disables censorship circumvention for all new connections (until changed).
     *
     * If CC is enabled, *new* connections and services may try additional routes to the Signal
     * servers. Existing connections and services will continue with the setting they were created
     * with. (In particular, changing this setting will not affect any existing
     * {@link ChatConnection ChatConnections}.)
     *
     * CC is off by default.
     */
    setCensorshipCircumventionEnabled(enabled: boolean): void;
    /**
     * Sets the proxy host to be used for all new connections (until overridden).
     *
     * Sets a server to be used to proxy all new outgoing connections. The proxy can be overridden by
     * calling this method again or unset by calling {@link #clearProxy}. Omitting the `port` means
     * the default port for the scheme will be used.
     *
     * To specify a Signal transparent TLS proxy, use {@link SIGNAL_TLS_PROXY_SCHEME}, or the
     * overload that takes a separate domain and port number.
     *
     * Throws if the scheme is unsupported or if the provided parameters are invalid for that scheme
     * (e.g. Signal TLS proxies don't support authentication)
     */
    setProxy(options: Readonly<ProxyOptions>): void;
    /**
     * Sets the Signal TLS proxy host to be used for all new connections (until overridden).
     *
     * Sets a domain name and port to be used to proxy all new outgoing connections, using a Signal
     * transparent TLS proxy. The proxy can be overridden by calling this method again or unset by
     * calling {@link #clearProxy}.
     *
     * Throws if the host or port is structurally invalid, such as a port that doesn't fit in u16.
     */
    setProxy(host: string, port?: number): void;
    /**
     * Like {@link #setProxy}, but parses the proxy options from a URL. See there for more
     * information.
     *
     * Takes a string rather than a URL so that an *invalid* string can result in disabling
     * connections until {@link #clearProxy} is called, consistent with other ways {@link #setProxy}
     * might consider its parameters invalid.
     *
     * Throws if the URL contains unnecessary parts (like a query string), or if the resulting options
     * are not supported.
     */
    setProxyFromUrl(urlString: string): void;
    /**
     * Parses a proxy URL into an options object, suitable for passing to {@link #setProxy}.
     *
     * It is recommended not to call this directly. Instead, use {@link #setProxyFromUrl}, which will
     * treat an invalid URL uniformly with one that is structurally valid but unsupported by
     * libsignal.
     *
     * Throws if the URL is known to not be a valid proxy URL; however it's still possible the
     * resulting options object cannot be used as a proxy.
     */
    static proxyOptionsFromUrl(urlString: string): ProxyOptions;
    /**
     * Refuses to make any new connections until a new proxy configuration is set or
     * {@link #clearProxy} is called.
     *
     * Existing connections will not be affected.
     */
    setInvalidProxy(): void;
    /**
     * Ensures that future connections will be made directly, not through a proxy.
     *
     * Clears any proxy configuration set via {@link #setProxy} or {@link #setInvalidProxy}. If none
     * was set, calling this method is a no-op.
     */
    clearProxy(): void;
    /**
     * Notifies libsignal that the network has changed.
     *
     * This will lead to, e.g. caches being cleared and cooldowns being reset.
     */
    onNetworkChange(): void;
    cdsiLookup({ username, password }: Readonly<ServiceAuth>, { e164s, acisAndAccessKeys, abortSignal, useNewConnectLogic, }: ReadonlyDeep<CDSRequestOptionsType>): Promise<CDSResponseType<string, string>>;
}
export {};
