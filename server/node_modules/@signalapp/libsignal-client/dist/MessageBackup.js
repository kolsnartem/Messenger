"use strict";
//
// Copyright 2024 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.ComparableBackup = exports.OnlineBackupValidator = exports.validate = exports.Purpose = exports.MessageBackupKey = exports.ValidationOutcome = void 0;
/**
 * Message backup validation routines.
 *
 * @module MessageBackup
 */
const Native = require("../Native");
const AccountKeys_1 = require("./AccountKeys");
/**
 * Result of validating a message backup bundle.
 */
class ValidationOutcome {
    /**
     * `true` if the backup is valid, `false` otherwise.
     *
     * If this is `true`, there might still be messages about unknown fields.
     */
    get ok() {
        return this.errorMessage == null;
    }
    constructor(outcome) {
        const { errorMessage, unknownFieldMessages } = outcome;
        this.errorMessage = errorMessage;
        this.unknownFieldMessages = unknownFieldMessages;
    }
}
exports.ValidationOutcome = ValidationOutcome;
/**
 * Key used to encrypt and decrypt a message backup bundle.
 *
 * @see {@link BackupKey}
 */
class MessageBackupKey {
    constructor(inputOrMasterKeyBytes, maybeAci) {
        if (inputOrMasterKeyBytes instanceof Buffer) {
            if (maybeAci === undefined)
                throw new Error('missing ACI parameter');
            this._nativeHandle = Native.MessageBackupKey_FromMasterKey(inputOrMasterKeyBytes, maybeAci.getServiceIdFixedWidthBinary());
        }
        else if ('accountEntropy' in inputOrMasterKeyBytes) {
            const { accountEntropy, aci } = inputOrMasterKeyBytes;
            this._nativeHandle = Native.MessageBackupKey_FromAccountEntropyPool(accountEntropy, aci.getServiceIdFixedWidthBinary());
        }
        else {
            const { backupId } = inputOrMasterKeyBytes;
            let { backupKey } = inputOrMasterKeyBytes;
            if (backupKey instanceof AccountKeys_1.BackupKey) {
                backupKey = backupKey.contents;
            }
            this._nativeHandle = Native.MessageBackupKey_FromBackupKeyAndBackupId(backupKey, backupId);
        }
    }
    /** An HMAC key used to sign a backup file. */
    get hmacKey() {
        return Native.MessageBackupKey_GetHmacKey(this);
    }
    /** An AES-256-CBC key used to encrypt a backup file. */
    get aesKey() {
        return Native.MessageBackupKey_GetAesKey(this);
    }
}
exports.MessageBackupKey = MessageBackupKey;
// This must match the Rust version of the enum.
var Purpose;
(function (Purpose) {
    Purpose[Purpose["DeviceTransfer"] = 0] = "DeviceTransfer";
    Purpose[Purpose["RemoteBackup"] = 1] = "RemoteBackup";
})(Purpose || (exports.Purpose = Purpose = {}));
/**
 * Validate a backup file
 *
 * @param backupKey The key to use to decrypt the backup contents.
 * @param purpose Whether the backup is intended for device-to-device transfer or remote storage.
 * @param inputFactory A function that returns new input streams that read the backup contents.
 * @param length The exact length of the input stream.
 * @returns The outcome of validation, including any errors and warnings.
 * @throws IoError If an IO error on the input occurs.
 *
 * @see OnlineBackupValidator
 */
async function validate(backupKey, purpose, inputFactory, length) {
    const firstStream = inputFactory();
    const secondStream = inputFactory();
    return new ValidationOutcome(await Native.MessageBackupValidator_Validate(backupKey, firstStream, secondStream, length, purpose));
}
exports.validate = validate;
/**
 * An alternative to {@link validate()} that validates a backup frame-by-frame.
 *
 * This is much faster than using `validate()` because it bypasses the decryption and decompression
 * steps, but that also means it's validating less. Don't forget to call `finalize()`!
 *
 * Unlike `validate()`, unknown fields are treated as "soft" errors and logged, rather than
 * collected and returned to the app for processing.
 *
 * # Example
 *
 * ```
 * const validator = new OnlineBackupValidator(
 *     backupInfoProto.serialize(),
 *     Purpose.deviceTransfer)
 * repeat {
 *   // ...generate Frames...
 *   validator.addFrame(frameProto.serialize())
 * }
 * validator.finalize() // don't forget this!
 * ```
 */
class OnlineBackupValidator {
    /**
     * Initializes an OnlineBackupValidator from the given BackupInfo protobuf message.
     *
     * "Soft" errors will be logged, including unrecognized fields in the protobuf.
     *
     * @throws BackupValidationError on error
     */
    constructor(backupInfo, purpose) {
        this._nativeHandle = Native.OnlineBackupValidator_New(backupInfo, purpose);
    }
    /**
     * Processes a single Frame protobuf message.
     *
     * "Soft" errors will be logged, including unrecognized fields in the protobuf.
     *
     * @throws BackupValidationError on error
     */
    addFrame(frame) {
        Native.OnlineBackupValidator_AddFrame(this, frame);
    }
    /**
     * Marks that a backup is complete, and does any final checks that require whole-file knowledge.
     *
     * "Soft" errors will be logged.
     *
     * @throws BackupValidationError on error
     */
    finalize() {
        Native.OnlineBackupValidator_Finalize(this);
    }
}
exports.OnlineBackupValidator = OnlineBackupValidator;
/**
 * An in-memory representation of a backup file used to compare contents.
 *
 * When comparing the contents of two backups:
 *   1. Create a `ComparableBackup` instance for each of the inputs.
 *   2. Check the `unknownFields()` value; if it's not empty, some parts of the
 *      backup weren't parsed and won't be compared.
 *   3. Produce a canonical string for each backup with `comparableString()`.
 *   4. Compare the canonical string representations.
 *
 * The diff of the canonical strings (which may be rather large) will show the
 * differences between the logical content of the input backup files.
 */
class ComparableBackup {
    constructor(handle) {
        this._nativeHandle = handle;
    }
    /**
     * Read an unencrypted backup file into memory for comparison.
     *
     * @param purpose Whether the backup is intended for device-to-device transfer or remote storage.
     * @param input An input stream that reads the backup contents.
     * @param length The exact length of the input stream.
     * @returns The in-memory representation.
     * @throws BackupValidationError If an IO error occurs or the input is invalid.
     */
    static async fromUnencrypted(purpose, input, length) {
        const handle = await Native.ComparableBackup_ReadUnencrypted(input, length, purpose);
        return new ComparableBackup(handle);
    }
    /**
     * Produces a string representation of the contents.
     *
     * The returned strings for two backups will be equal if the backups contain
     * the same logical content. If two backups' strings are not equal, the diff
     * will show what is different between them.
     *
     * @returns a canonical string representation of the backup
     */
    comparableString() {
        return Native.ComparableBackup_GetComparableString(this);
    }
    /**
     * Unrecognized protobuf fields present in the backup.
     *
     * If this is not empty, some parts of the backup were not recognized and
     * won't be present in the string representation.
     */
    get unknownFields() {
        return Native.ComparableBackup_GetUnknownFields(this);
    }
}
exports.ComparableBackup = ComparableBackup;
//# sourceMappingURL=MessageBackup.js.map