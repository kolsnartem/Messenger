"use strict";
//
// Copyright 2023 Signal Messenger, LLC.
// SPDX-License-Identifier: AGPL-3.0-only
//
Object.defineProperty(exports, "__esModule", { value: true });
exports.chunkSizeInBytes = exports.ValidatingPassThrough = exports.ValidatingWritable = exports.DigestingPassThrough = exports.DigestingWritable = exports.inferChunkSize = exports.everyNthByte = void 0;
const Native = require("../Native");
const stream = require("stream");
const Errors_1 = require("./Errors");
function everyNthByte(n) {
    return { kind: 'everyN', n: n };
}
exports.everyNthByte = everyNthByte;
function inferChunkSize(dataSize) {
    return { kind: 'chunksOf', dataSize: dataSize };
}
exports.inferChunkSize = inferChunkSize;
/**
 * @deprecated Use the DigestingPassThrough instead
 */
class DigestingWritable extends stream.Writable {
    constructor(key, sizeChoice) {
        super();
        this._digests = [];
        this._nativeHandle = Native.IncrementalMac_Initialize(key, chunkSizeInBytes(sizeChoice));
    }
    getFinalDigest() {
        return Buffer.concat(this._digests);
    }
    _write(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    chunk, encoding, callback) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        const buffer = Buffer.from(chunk, encoding);
        const next_digest = Native.IncrementalMac_Update(this, buffer, 0, buffer.length);
        if (next_digest.length != 0) {
            this._digests.push(next_digest);
        }
        callback();
    }
    _final(callback) {
        this._digests.push(Native.IncrementalMac_Finalize(this));
        callback();
    }
}
exports.DigestingWritable = DigestingWritable;
class DigestingPassThrough extends stream.Transform {
    constructor(key, sizeChoice) {
        super();
        this.digester = new DigestingWritable(key, sizeChoice);
        // We handle errors coming from write/end
        this.digester.on('error', () => {
            /* noop */
        });
    }
    getFinalDigest() {
        return this.digester.getFinalDigest();
    }
    _transform(data, enc, callback) {
        this.digester.write(data, enc, (err) => {
            if (err) {
                return callback(err);
            }
            this.push(data);
            callback();
        });
    }
    _final(callback) {
        this.digester.end((err) => {
            if (err) {
                return callback(err);
            }
            callback();
        });
    }
}
exports.DigestingPassThrough = DigestingPassThrough;
/**
 * @deprecated Use the ValidatingPassThrough instead
 */
class ValidatingWritable extends stream.Writable {
    constructor(key, sizeChoice, digest) {
        super();
        this._validatedBytes = 0;
        this._nativeHandle = Native.ValidatingMac_Initialize(key, chunkSizeInBytes(sizeChoice), digest);
    }
    validatedSize() {
        return this._validatedBytes;
    }
    _write(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    chunk, encoding, callback) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        const buffer = Buffer.from(chunk, encoding);
        const validBytes = Native.ValidatingMac_Update(this, buffer, 0, buffer.length);
        if (validBytes >= 0) {
            this._validatedBytes += validBytes;
            callback();
        }
        else {
            callback(makeVerificationError('Corrupted input data'));
        }
    }
    _final(callback) {
        const validBytes = Native.ValidatingMac_Finalize(this);
        if (validBytes >= 0) {
            this._validatedBytes += validBytes;
            callback();
        }
        else {
            callback(makeVerificationError('Corrupted input data (finalize)'));
        }
    }
}
exports.ValidatingWritable = ValidatingWritable;
class ValidatingPassThrough extends stream.Transform {
    constructor(key, sizeChoice, digest) {
        super();
        this.buffer = new Array();
        this.validator = new ValidatingWritable(key, sizeChoice, digest);
        // We handle errors coming from write/end
        this.validator.on('error', () => {
            /* noop */
        });
    }
    _transform(data, enc, callback) {
        const start = this.validator.validatedSize();
        this.validator.write(data, enc, (err) => {
            if (err) {
                return callback(err);
            }
            this.buffer.push(data);
            const end = this.validator.validatedSize();
            const readySize = end - start;
            // Fully buffer
            if (readySize === 0) {
                return callback(null);
            }
            const { buffer } = this;
            this.buffer = [];
            let validated = 0;
            for (const chunk of buffer) {
                validated += chunk.byteLength;
                // Buffered chunk is fully validated - push it without slicing
                if (validated <= readySize) {
                    this.push(chunk);
                    continue;
                }
                // Validation boundary lies within the chunk, split it
                const notValidated = validated - readySize;
                this.push(chunk.subarray(0, -notValidated));
                this.buffer.push(chunk.subarray(-notValidated));
                // Technically this chunk must be the last chunk so we could break,
                // but for consistency keep looping.
            }
            callback(null);
        });
    }
    _final(callback) {
        const start = this.validator.validatedSize();
        this.validator.end((err) => {
            if (err) {
                return callback(err);
            }
            const end = this.validator.validatedSize();
            const readySize = end - start;
            const buffer = Buffer.concat(this.buffer);
            this.buffer = [];
            if (buffer.byteLength !== readySize) {
                return callback(new Error('Stream not fully processed'));
            }
            this.push(buffer);
            callback(null);
        });
    }
}
exports.ValidatingPassThrough = ValidatingPassThrough;
function chunkSizeInBytes(sizeChoice) {
    switch (sizeChoice.kind) {
        case 'everyN':
            return sizeChoice.n;
            break;
        case 'chunksOf':
            return Native.IncrementalMac_CalculateChunkSize(sizeChoice.dataSize);
            break;
    }
}
exports.chunkSizeInBytes = chunkSizeInBytes;
function makeVerificationError(message) {
    return new Errors_1.LibSignalErrorBase(message, 'VerificationFailed', 'incremental_mac');
}
//# sourceMappingURL=incremental_mac.js.map